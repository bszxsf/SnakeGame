# 简介
该项目是为了对新人进行简单的C语言Linux开发培训而设置。程序中包含了一些Linux开发的基本API，并包含了一个实现贪吃蛇的算法。代码中技巧并不多，适合用若干天至若干周时间理解透彻和学会其中的基本设计思想。
注意：算法和API部分不适合C语言基础较差的学生。

# 必需工具
* 拥有完整开发包的Linux发行版（例如Ubuntu）
* GNU/GCC工具链
* make（通常自带）

# 使用方法
该源码只适用于Linux，并已在Ubuntu 14.04上以gcc 8.3.0成功编译。在源码所在目录打开终端，输入make即可生成可执行文件snake。在终端输入./snake运行程序。make clean即可清除已经生成的文件。make clean-syslog可以清除系统日志，而make check-syslog将会显示出当前系统日志。

# 任务
这段样例代码包含了多方位的技巧和知识，请从比较熟悉或感兴趣的部分开始逐步理解该程序。

## 编译方法
难度：简单
打开Makefile，理解gcc指令的使用方法，学会使用gcc手动编译源文件和链接，了解源码是如何一步步生成可执行文件的。
可选任务：
* 学习Makefile语法，将提供的Makefile变得更为通用。
* 尝试将除了main.c外的源文件打包成.so共享库或.a归档文件，并和main.c编译生成的main.o链接。

## 基本语法
难度：简单
观察和理解game.c中数组和控制语句的含义，理解该算法的基本运作原理，理解文件操作的方法。文件输入输出是重要调试手段，printf和scanf本质上也是经由文件完成。
可选任务：
* calc_cycle用于计算当前周期结束后的状态。请尝试将其中用于遍历蛇身的部分改为递归。
* read_rank和write_rank中使用了C标准库函数。试将其改为由文件描述符实现。思考：为什么这里一般用标准库函数，而不直接调用系统的文件描述符API？
* game.c的随机数生成使用了rand函数。尝试利用/dev/urandom来实现同样的事情。思考：为什么不用/dev/random？

## 调试和运营维护
难度：一般
观察和理解syslog，fprintf的行为，熟悉fflush的意义以及为什么要用fflush，知道stdout、stdin和stderr，以及对应FILENO的区别。提示：Ubuntu的系统日志通常位于/var/log/syslog，程序把一部分信息输出到了这里。
观察和理解signal的行为，简要了解操作系统中的PID，以及用户UID和EUID的区别（不过本程序没有体现后者）。熟悉exit，abort函数和return的关系，自行了解segmentation fault的意义和调试手段。请指出哪些部分存在相应风险。
可选任务：
* 实现一个程序，利用stdout和stderr分别输出信息，并尝试丢弃stderr的输出。提示：重定向和/dev/null。
* 设计一个程序，其打开另一个进程，并在子进程结束后不断尝试重新打开它。其本身收到SIGINT信号后输出提示，过5s再终止程序。不用管子进程，initd会接手它（如果它存在的话）。

## 理解设计方法
难度：简单
观察和了解Linux系统返回值和参数设计思想，了解什么时候用指针，什么时候不用。了解创建和使用缓冲区的常见规则。
可选任务：
* 设计一个程序，包含一个可以求出若干int型变量的异或和，但只处理第一个0之前的部分。输入是一个不定长的int数组及其长度（含中间出现的0），从stdin输入。当遇到0但处理尚未完成时，返回当前结果，用一个指针告知调用者具体被处理的数据数目。如果处理的长度为0，异或和按-1处理。保证所有输入非负。例如：
【样例输入1】
7
1 2 3 4 5 0 1
【样例输出1】
1 5
【样例解释】
1是前五个输入的异或和，5表示第一个0之前有五个数。
【样例输入2】
5
0 1 2 3 4
【样例输出2】
-1 0
【样例解释】
第一个数就是0，处理长度为0，异或和按-1处理。
提示：用指针代替数组。

